package claire.util.crypto.hash.primitive.BEAR;

import claire.util.crypto.rng.RandUtils;
import claire.util.crypto.rng.primitive.MersenneTwister;
import claire.util.encoding.BitEncoder;
import claire.util.memory.array.D2_1Array;

/**
 * This function is mostly a toy hash, exhibits poor collision resistance.
 * Do not use for any serious application.
 * 
 * <s><h1>BEAR-1</h1> Revision 3
 * <br><br>
 * BEAR-1 is a long, difficult to parallelize and configurable algorithm.
 * <br><br>
 * Internally, it randomizes and then performs all forms of logic operations on the input
 * a configurable amount of times. The internal buffer can be changed using the N-Factor 
 * setting. Higher N-Factors will use more memory an take linearly higher amounts of time
 * to complete. The amount of operations it performs is dependent on the T-Factor. Higher
 * T-Factors will perform the randomization and logic operations more on the same data
 * (MISD) (Again, this cannot be parallelized) use higher T-Factors to linearly increase
 * hashing time for security. Finally, the length of each BEAR-1 hash can be manipulated
 * with the aptly named L-Factor. The L-Factor only changes the recompression stage of the
 * hash where it reduces the internal buffer to the length specified. Ensuring that the L-
 * Factor is:<br>
 * <table>
 * <tr><td>1.</td><td>Lower than the size of the internal buffer (N << 11)</td></tr>
 * <tr><td>2.</td><td>The internal buffer is divisible by the length (Factor of 2, generally)
 * </td></tr></table>
 * Will ensure that the security of the hash is difficult to compromise. Doing this incorrectly
 * will force the recompression function to fill in the gaps with bits generated by the 
 * PRNG (Not cryptographically secure).</s>
 * 
 * @author Claire
 */
public final class $BEAR1 {
	
	private boolean[][] scratchpad;
	
	private final int N, Nf; 
	private final int T;
	private final int L;
	
	private boolean hasValue = false;
	
	private MersenneTwister prng;
	private final BearUtil util;
	
	{
		prng = new MersenneTwister();
		util = new BearUtil();
	}
	
	/**
	 * WARNING: Ensure to set a T-Factor of AT LEAST
	 * 2, a T-Factor of one is insecure and prone to 
	 * bias with a nonstandard amount of bits
	 * 
	 * @author Claire
	 * @param N
	 * @param T
	 * @param L
	 */
	public $BEAR1(int N, int T, int L)
	{
		this.N = N; this.Nf = this.N << 11;
		this.T = T;
		this.L = L;
		if(L > Nf) throw new java.lang.ExceptionInInitializerError("Length cannot exceed internal scratchpad! Increase N-Factor or decrease target length!");
		if((Nf % L) != 0) System.out.println("WARNING! The internal scratchpad length is not divisible by the specified hash lengh! Zeroes at the end of the hash will be filled in randomly. NOT CRYPTOGRAPHICALLY SECURE!! WARNING!!");
		scratchpad = new boolean[2][Nf];
	}
	
	/**
	 * WARNING: Ensure to set a T-Factor of AT LEAST
	 * 2, a T-Factor of one is insecure and prone to 
	 * bias with a nonstandard amount of bits
	 * 
	 * @author Claire
	 * @param N
	 * @param T
	 * @param L
	 * @param b
	 */
	public $BEAR1(int N, int T, int L, final boolean[] b)
	{
		this.N = N; this.Nf = this.N << 11;
		this.T = T;
		this.L = L;
		if(L > Nf) throw new java.lang.ExceptionInInitializerError("Length cannot exceed internal scratchpad! Increase N-Factor or decrease target length!");
		if((Nf % L) != 0) System.out.println("WARNING! The internal scratchpad length is not divisible by the specified hash lengh! Zeroes at the end of the hash will be filled in randomly. NOT CRYPTOGRAPHICALLY SECURE!! WARNING!!");
		scratchpad = new boolean[2][Nf];
		init(b);
	}
	
	/**
	 * Sets the PRNG to be used
	 * 
	 * @param rand
	 */
	public void setPRNG(MersenneTwister rand)
	{
		this.prng = rand;
	}
	
	/**
	 * Initializes the BEAR-1 processor with a set of booleans. Must be equal to N << 11
	 * @param b
	 */
	public final void init(final boolean[] b)
	{
		if(b.length != Nf) throw new java.lang.IllegalArgumentException();
		scratchpad[0] = b;
		boolean[] b2 = new boolean[b.length];
		for(int i = 0; i < b.length; i++) 
			b2[i] = !b[i];
		scratchpad[1] = b2;
		this.hasValue = true;
	}
	
	/**
	 * Performs login on both the input and mirror.
	 * <br><br>
	 * Cannot be parallelized. Each operation requires the previous bit, so this ensures it must
	 * be done sequentially. Internally, this function loops through the input and mirror and
	 * performs AND, NAND, OR, NOR, XOR, XNOR, or NOT on each set of two booleans. (For NOT
	 * it uses the first and last value based on the PRNG).
	 */
	private final void performLogic()
	{
		final boolean[] ninput = scratchpad[0];
		final boolean[] iinput = scratchpad[1];
		ninput[0] = util.logic(prng.nextBoolean(), ninput[0]);
		iinput[0] = util.logic(prng.nextBoolean(), iinput[0]);
		for(int i = 1; i < Nf; i++) {
			ninput[i] = util.logic(ninput[i - 1], ninput[i]);
			iinput[i] = util.logic(iinput[i - 1], iinput[i]);
		}
	}
	
	/**
	 * Fisher-Yates Shuffle.
	 * 
	 * @deprecated
	 */
	@SuppressWarnings("unused")
	private final void randomize()
	{
		final boolean[] ninput = scratchpad[0];
		final boolean[] iinput = scratchpad[1];
		prng.setSeed(util.getTrue(true));
		boolean t1, t2;
		int t3, t4;
		for(int i = iinput.length - 1; i > 1; i--) {
			t1 = ninput[i]; 	      t2 = iinput[i];
			t3 = RandUtils.inrange_best(prng, i + 1); t4 = RandUtils.inrange_best(prng, i + 1);
			ninput[i] = ninput[t3];   iinput[i] = iinput[t4];
			ninput[t3] = t1; 		  iinput[t4] = t2;
		}
	}
	
	/**
	 * A Fisher-Yates shuffle that does the entire array at once.
	 * (As opposed to two seperate shuffles for each the input and
	 * the mirror)
	 */
	private final void randomize2()
	{
		D2_1Array.Bool array = new D2_1Array.Bool(this.scratchpad);
		prng.setSeed(util.getTrue(false));
		boolean t1;
		int t2;
		for(int i = array.length() - 1; i > 1; i--)
		{
			t1 = array.get(i);
			t2 = RandUtils.inrange_best(prng, i + 1);
			array.set(i, array.get(t2));
			array.set(t2, t1);
		}
	}
	
	/**
	 * Performs the randomize and logic functions depending on the T-Factor.
	 */
	public final void hash()
	{
		if(!this.hasValue) throw new java.lang.NullPointerException("No input");
		for(int i = 0; i < T; i++) {
			randomize2();
			performLogic();
		}
	}
	
	@SuppressWarnings("unused")
	private final void print()
	{
		System.out.println("Input: " + new String(BitEncoder.toBase64(scratchpad[0])));
		System.out.println("Mirror: " + new String(BitEncoder.toBase64(scratchpad[1])));
	}
	
	/**
	 * Reduces the scratchpad down to the specified length.
	 * @return
	 */
	public final boolean[] SCI_1()
	{
		final boolean[] ninput = scratchpad[0];
		final boolean[] iinput = scratchpad[1];
		final boolean[] hash = new boolean[L];
		boolean[] t1 = new boolean[Nf];
		for(int i = 0; i < Nf; i++) 
			t1[i] = util.logic(ninput[i], iinput[i]);
		boolean[] t2;
		while(t1.length > L) {
			t2 = t1;
			t1 = new boolean[t1.length / 2];
			for(int i = 0; i < t1.length; i++)
				t1[i] = util.logic(t2[i << 1], t2[(i << 1) + 1]);
		} 
		for(int i = 0; i < t1.length; i++)
			hash[i] = t1[i];
		if(t1.length != hash.length) {
			for(int i = t1.length; i < hash.length; i++)
				hash[i] = prng.nextBoolean();
		}
		return hash;
	}
	
	private final class BearUtil 
	{

		/**
		 * Generates a number based on the amount of bits that are true and their positions.
		 * <br><br>
		 * This function relies on the previous number, and cannot be parallelized. There 
		 * is a possible attack where the attacker could optimize a brute-force attack by
		 * knowing that the first part of the input will be the same, and re-use that value
		 * and start the loop where the change starts. Mitigating this attack involves putting
		 * changing parts of the hash in the FRONT of the input, changing the whole loop and forcing
		 * an attacker to calculate the entire function.
		 * <br><br>
		 * Even if two different bitsets contain the same number of true bits, the output of 
		 * getTrue will be different, as it is dependent on position as well as amount.
		 * <br><br>
		 * eg. 1010 yields a different result than 0101.
		 * <br><br>
		 * True uses the input, false uses the mirror.
		 * 
		 * @param b
		 * @return
		 */
		private final long getTrue(boolean b)
		{
			final boolean bools[];
			if(b) {
				bools = scratchpad[0];
			} else {
				bools = scratchpad[1];
			}
			long f = 0;
			int ii = 0;
			for(int i = 0; i < Nf; i++) 
				if(bools[i]) {
					f += (i - ii);
					ii++;
				}
			return f;
		}
		
		/**
		 * Performs NOR, OR, NAND, AND, XNOR, XOR, or NOT on two booleans.
		 * 
		 * @param b1
		 * @param b2
		 * @return
		 */
		private final boolean logic(boolean b1, boolean b2)
		{
			switch(RandUtils.inrange_best(prng, 7)) {
				case 0:
					//AND
					return b1 && b2;
				case 1:
					//NAND
					return !(b1 && b2);
				case 2:
					//OR
					return b1 || b2;
				case 3:
					//NOR
					return !(b1 || b2);
				case 4:
					//XOR
					return b1 ^ b2;
				case 5:
					//XNOR
					return !(b1 ^ b2);
				case 6:
					/*
					 *  NOT
					 * 
					 *  Uses the PRNG to decide whether to use the first or last bit.
					 */
					if(prng.nextBoolean())
						return !b1;
					else 
						return !b2;
				default:
					throw new java.lang.ArithmeticException();
			}
		}

	}

}