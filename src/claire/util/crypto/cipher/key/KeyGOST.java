package claire.util.crypto.cipher.key;

import claire.util.memory.Bits;
import claire.util.standards._NAMESPACE;

public class KeyGOST extends ByteKey<KeyGOST> {
	
	private boolean hasS = false;
	
	private static final byte[] DEFAULT = 
	{
        0x04, 0x0A, 0x09, 0x02, 0x0D, 0x08, 0x00, 0x0E,
        0x06, 0x0B, 0x01, 0x0C, 0x07, 0x0F, 0x05, 0x03, 
        0x0E, 0x0B, 0x04, 0x0C, 0x06, 0x0D, 0x0F, 0x0A, 
        0x02, 0x03, 0x08, 0x01, 0x00, 0x07, 0x05, 0x09, 
        0x05, 0x08, 0x01, 0x0D, 0x0A, 0x03, 0x04, 0x02, 
        0x0E, 0x0F, 0x0C, 0x07, 0x06, 0x00, 0x09, 0x0B, 
        0x07, 0x0D, 0x0A, 0x01, 0x00, 0x08, 0x09, 0x0F, 
        0x0E, 0x04, 0x06, 0x0C, 0x0B, 0x02, 0x05, 0x03, 
        0x06, 0x0C, 0x07, 0x01, 0x05, 0x0F, 0x0D, 0x08, 
        0x04, 0x0A, 0x09, 0x0E, 0x00, 0x03, 0x0B, 0x02, 
        0x04, 0x0B, 0x0A, 0x00, 0x07, 0x02, 0x01, 0x0D,
        0x03, 0x06, 0x08, 0x05, 0x09, 0x0C, 0x0F, 0x0E, 
        0x0D, 0x0B, 0x04, 0x01, 0x03, 0x0F, 0x05, 0x09,
        0x00, 0x0A, 0x0E, 0x07, 0x06, 0x08, 0x02, 0x0C, 
        0x01, 0x0F, 0x0D, 0x00, 0x05, 0x07, 0x0A, 0x04,
        0x09, 0x02, 0x03, 0x0E, 0x06, 0x0B, 0x08, 0x0C
    };

	public KeyGOST(byte[] key, int size) 
	{
		super(KeyGOST.class, key, size);
	}
	
	public KeyGOST(byte[] key)
	{
		super(KeyGOST.class, key);
	}
	
	protected int getLength(byte[] bytes, int size)
	{
		if(size == 96) {
			hasS = true;
			return 96;
		} else if(size == 32) 
			return 32;
		else 
			throw new java.lang.IllegalArgumentException("AES keys are 128, 192, or 256 bits.");
	}
	
	public void getSBOX(byte[] SBOX)
	{
		if(hasS) 
			Bits.bytesToNibbles(this.getBytes(), 32, SBOX, 0, 64);
		else
			System.arraycopy(DEFAULT, 0, SBOX, 0, 128);
	}
	
	public void getKey(byte[] out)
	{
		System.arraycopy(this.getBytes(), 0, out, 0, 32);
	}

	public int NAMESPACE()
	{
		return _NAMESPACE.KEYGOST;
	}

	protected KeyGOST construct(byte[] bytes)
	{
		return new KeyGOST(bytes);
	}

}
